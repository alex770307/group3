public interface Calculator {
    double convert(double amount, CurrencyType fromCurrency, CurrencyType toCurrency);
}
//- `public interface Calculator`:
//- **public**: Указывает, что интерфейс можно использовать в любых других классах.
//- **interface**: Ключевое слово, обозначающее, что мы определяем интерфейс.
//- **Calculator**: Название интерфейса.
//
//- `double convert(double amount, CurrencyType fromCurrency, CurrencyType toCurrency)`:
//- **double convert**: Определяет метод, который возвращает значение типа `double`. Название метода — `convert`.
//- **double amount**: Входной параметр метода, представляющий сумму денег, которую нужно конвертировать.
//- **CurrencyType fromCurrency**: Входной параметр метода, представляющий исходную валюту типа `CurrencyType`.
//- **CurrencyType toCurrency**: Входной параметр метода, представляющий целевую валюту типа `CurrencyType`.

//### Что происходит в этом интерфейсе?
//
//1. **Объявление интерфейса**: Мы объявляем интерфейс с именем `CurrencyConverterInput`,
// который будет определять контракт для конвертации валют.
//
//2. **Метод без реализации**: Интерфейс содержит абстрактный метод `convert`,
// который принимает сумму денег вместе с исходной и целевой валютами,
// и возвращает сумму после конвертации.
//
//Этот интерфейс указывает, что любой класс, который его реализует,
// должен предоставить конкретную реализацию метода `convert`.

//### Зачем это нужно?
//
//1. **Гибкость и расширяемость**: Использование интерфейсов
// позволяет легко заменять или расширять реализацию класса.
// Например, если вам потребуется другая логика конвертации,
// вы можете создать новый класс, реализующий этот интерфейс,
// и использовать его без изменений в основном коде программы.
//
//2. **Независимость от реализации**: Код, который использует интерфейс,
// не зависит от конкретной реализации, что упрощает тестирование,
// поддержку и модульное программирование

//Таким образом, интерфейс `Calculator` определяет контракт для конвертации валют,
// который может быть реализован разными классами с различной логикой,
// предоставляя гибкость и независимость в написании кода приложения.